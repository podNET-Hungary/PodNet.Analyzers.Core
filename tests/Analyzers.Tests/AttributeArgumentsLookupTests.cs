using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using PodNet.Analyzers.CodeAnalysis;
using System.Runtime.Loader;

namespace PodNet.Analyzers.Tests;

[TestClass]
public class AttributeArgumentsLookupTests
{
    [TestMethod]
    public void AttributeArgumentsLookup_HappyPathWorks()
    {
        var globalUsings = CSharpSyntaxTree.ParseText("""
            // <auto-generated/>
            global using global::System;
            global using global::System.Collections.Generic;
            global using global::System.IO;
            global using global::System.Linq;
            global using global::System.Net.Http;
            global using global::System.Threading;
            global using global::System.Threading.Tasks;
            """);

        var attributeTree = CSharpSyntaxTree.ParseText("""
            [Test(
                IntValue = 1,
                EnumValue = DateTimeKind.Local,
                StringValue = "String",
                TypeValue = typeof(TestAttribute),
                StringArrayValue = ["String1", "String2"],
                ObjectArrayValue = ["String1", 2])]
            public sealed class TestAttribute : Attribute
            {
                public int IntValue { get; set; }
                public DateTimeKind EnumValue { get; set; }
                public DateTimeKind UnsetEnumValue { get; set; }
                public required string? StringValue { get; init; }
                public string? UnsetStringValue { get; init; }
                public Type? TypeValue { get; set; }
                public string[]? StringArrayValue { get; set; }
                public object[]? ObjectArrayValue { get; set; }
            }
            """);

        var compilation = CSharpCompilation.Create(null,
            syntaxTrees: [globalUsings, attributeTree],
            references: AssemblyLoadContext.Default.Assemblies
                            .Where(a => !a.IsDynamic && !string.IsNullOrWhiteSpace(a.Location))
                            .Select(a => MetadataReference.CreateFromFile(a.Location)), 
            options: new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));

        System.Collections.Immutable.ImmutableArray<Diagnostic> diagnostics = compilation.GetDiagnostics();
        Assert.AreEqual(0, diagnostics.Count(d => d.Severity is DiagnosticSeverity.Error));

        var model = compilation.GetSemanticModel(attributeTree);
        var classDeclarationSymbol = model.GetDeclaredSymbol(attributeTree.GetRoot()
            .DescendantNodes().OfType<ClassDeclarationSyntax>().First(c => c.AttributeLists.Count > 0));
        var attributeData = classDeclarationSymbol!.GetAttributes().Single();

        var lookup = AttributeArgumentsLookup.FromAttributeData(attributeData);

        Assert.AreEqual(1, lookup.GetValue<int?>("IntValue"));
        Assert.AreEqual("String", lookup.GetValue<string?>("StringValue"));
        Assert.IsNull(lookup.GetValue<string?>("UnsetStringValue"));
        Assert.AreEqual(DateTimeKind.Local, lookup.GetValue<DateTimeKind>("EnumValue"));
        Assert.AreEqual(DateTimeKind.Unspecified, lookup.GetValue<DateTimeKind>("UnsetEnumValue"));
        Assert.IsNull(lookup.GetValue<DateTimeKind?>("UnsetEnumValue"));
        Assert.AreEqual(DateTimeKind.Local, lookup.GetValue<DateTimeKind?>("EnumValue"));
        Assert.AreEqual("TestAttribute", lookup.GetType("TypeValue")!.ToString());
        CollectionAssert.AreEquivalent(lookup.GetArray<string>("StringArrayValue")!.Value, new List<string>() { "String1", "String2" });
        CollectionAssert.AreEquivalent(lookup.GetArray<object>("ObjectArrayValue")!.Value, new List<object>() { "String1", 2 });
    }
}
