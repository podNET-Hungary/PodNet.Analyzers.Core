using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using PodNet.Analyzers.CodeAnalysis;
using System.Runtime.Loader;

namespace PodNet.Analyzers.Tests;

[TestClass]
public class AttributeArgumentsLookupTests
{
    [TestMethod]
    public void AttributeArgumentsLookup_HappyPathWorks()
    {
        var globalUsings = CSharpSyntaxTree.ParseText("""
            // <auto-generated/>
            global using global::System;
            global using global::System.Collections.Generic;
            global using global::System.IO;
            global using global::System.Linq;
            global using global::System.Net.Http;
            global using global::System.Threading;
            global using global::System.Threading.Tasks;
            """);

        var attributeTree = CSharpSyntaxTree.ParseText("""
            [Test(
                IntValue = 1,
                StringValue = "String",
                TypeValue = typeof(TestAttribute),
                StringArrayValue = ["String1", "String2"],
                ObjectArrayValue = ["String1", 2])]
            public sealed class TestAttribute : Attribute
            {
                public int IntValue { get; set; }
                public required string? StringValue { get; init; }
                public string? UnsetStringValue { get; init; }
                public Type? TypeValue { get; set; }
                public string[]? StringArrayValue { get; set; }
                public object[]? ObjectArrayValue { get; set; }
            }
            """);

        var compilation = CSharpCompilation.Create(null,
            syntaxTrees: [globalUsings, attributeTree],
            references: AssemblyLoadContext.Default.Assemblies
                            .Where(a => !a.IsDynamic && !string.IsNullOrWhiteSpace(a.Location))
                            .Select(a => MetadataReference.CreateFromFile(a.Location)));

        var model = compilation.GetSemanticModel(attributeTree);
        var classDeclarationSymbol = model.GetDeclaredSymbol(attributeTree.GetRoot()
            .DescendantNodes().OfType<ClassDeclarationSyntax>().First(c => c.AttributeLists.Count > 0));
        var attributeData = classDeclarationSymbol!.GetAttributes().Single();

        var lookup = AttributeArgumentsLookup.FromAttributeData(attributeData);

        Assert.AreEqual(1, lookup.GetValue<int?>("IntValue"));
        Assert.AreEqual("String", lookup.GetValue<string?>("StringValue"));
        Assert.AreEqual(null, lookup.GetValue<string?>("UnsetStringValue"));
        Assert.AreEqual("TestAttribute", lookup.GetType("TypeValue")!.ToString());
        Assert.IsTrue(lookup.GetArray<string>("StringArrayValue")!.Value.SequenceEqual(["String1", "String2"]));
        Assert.IsTrue(lookup.GetArray<object>("ObjectArrayValue")!.Value.SequenceEqual(["String1", 2]));
    }
}
